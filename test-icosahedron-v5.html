<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Icosahedron (d20) - Canvas 3D</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }

    h1 {
      margin-bottom: 50px;
      text-align: center;
      font-size: 24px;
    }

    .demo-container {
      display: flex;
      gap: 100px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .demo {
      text-align: center;
    }

    .demo h2 {
      margin-bottom: 30px;
      font-size: 16px;
    }

    canvas {
      border: 1px solid #0f0;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }

    button {
      margin-top: 30px;
      padding: 10px 20px;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 20px #0f0;
    }

    .info {
      margin-top: 50px;
      text-align: center;
      color: #0f0;
      font-size: 14px;
      max-width: 600px;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <h1>[ 3D ICOSAHEDRON (d20) - CANVAS 3D ]</h1>
  
  <div class="demo-container">
    <div class="demo">
      <h2>SLOW SPIN</h2>
      <canvas id="canvas1" width="300" height="300"></canvas>
    </div>

    <div class="demo">
      <h2>FAST SPIN</h2>
      <canvas id="canvas2" width="300" height="300"></canvas>
    </div>
  </div>

  <div class="info">
    <p>[ TRUE ICOSAHEDRON GEOMETRY ]</p>
    <p>12 vertices | 30 edges | 20 faces</p>
    <p>Proper 3D projection with depth sorting</p>
  </div>

  <button onclick="location.reload()">REFRESH TO RESTART</button>

  <script>
    class Icosahedron {
      constructor(canvas, speed = 0.01) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.speed = speed;
        this.rotation = { x: -0.3, y: 0 };
        
        this.setupGeometry();
      }

      setupGeometry() {
        const phi = (1 + Math.sqrt(5)) / 2;
        const scale = 80;

        // 12 vertices
        const vertices = [
          [-1,  phi,  0],
          [ 1,  phi,  0],
          [-1, -phi,  0],
          [ 1, -phi,  0],
          [ 0, -1,  phi],
          [ 0,  1,  phi],
          [ 0, -1, -phi],
          [ 0,  1, -phi],
          [ phi,  0, -1],
          [ phi,  0,  1],
          [-phi,  0, -1],
          [-phi,  0,  1]
        ];

        // Normalize and scale
        this.vertices = vertices.map(v => {
          const length = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
          return [
            v[0]/length * scale,
            v[1]/length * scale,
            v[2]/length * scale
          ];
        });

        // 30 edges
        this.edges = [
          [0, 11], [0, 5], [0, 1], [0, 7], [0, 10],
          [1, 5], [1, 9], [1, 8], [1, 7],
          [2, 11], [2, 10], [2, 6], [2, 3], [2, 4],
          [3, 4], [3, 9], [3, 8], [3, 6],
          [4, 5], [4, 11], [4, 9],
          [5, 11],
          [6, 7], [6, 8], [6, 10],
          [7, 8], [7, 10],
          [8, 9],
          [9, 5],
          [10, 11]
        ];
      }

      rotateX(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return [
          point[0],
          point[1] * cos - point[2] * sin,
          point[1] * sin + point[2] * cos
        ];
      }

      rotateY(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return [
          point[0] * cos + point[2] * sin,
          point[1],
          -point[0] * sin + point[2] * cos
        ];
      }

      project(point) {
        // Simple perspective projection
        const distance = 300;
        const z = point[2] + distance;
        const scale = distance / z;
        return [
          point[0] * scale + this.width / 2,
          point[1] * scale + this.height / 2,
          z
        ];
      }

      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Rotate all vertices
        const rotated = this.vertices.map(v => {
          let p = this.rotateX(v, this.rotation.x);
          p = this.rotateY(p, this.rotation.y);
          return p;
        });

        // Project to 2D
        const projected = rotated.map(v => this.project(v));

        // Draw edges with depth
        const edgesWithDepth = this.edges.map(([i, j]) => {
          const v1 = projected[i];
          const v2 = projected[j];
          const avgZ = (v1[2] + v2[2]) / 2;
          return { i, j, z: avgZ };
        });

        // Sort by depth (far to near)
        edgesWithDepth.sort((a, b) => b.z - a.z);

        // Draw edges
        edgesWithDepth.forEach(edge => {
          const v1 = projected[edge.i];
          const v2 = projected[edge.j];
          
          // Opacity based on depth
          const opacity = Math.min(1, Math.max(0.3, (edge.z - 250) / 100));
          
          this.ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`;
          this.ctx.lineWidth = 2;
          this.ctx.shadowBlur = 4;
          this.ctx.shadowColor = '#0f0';
          
          this.ctx.beginPath();
          this.ctx.moveTo(v1[0], v1[1]);
          this.ctx.lineTo(v2[0], v2[1]);
          this.ctx.stroke();
        });

        // Draw vertices
        projected.forEach(v => {
          const opacity = Math.min(1, Math.max(0.4, (v[2] - 250) / 100));
          this.ctx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
          this.ctx.shadowBlur = 8;
          this.ctx.shadowColor = '#0f0';
          
          this.ctx.beginPath();
          this.ctx.arc(v[0], v[1], 4, 0, Math.PI * 2);
          this.ctx.fill();
        });

        // Reset shadow
        this.ctx.shadowBlur = 0;
      }

      animate() {
        this.rotation.y += this.speed;
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
    }

    // Create both icosahedrons (5x faster)
    const ico1 = new Icosahedron(document.getElementById('canvas1'), 0.025);
    const ico2 = new Icosahedron(document.getElementById('canvas2'), 0.05);

    ico1.animate();
    ico2.animate();
  </script>
</body>
</html>

