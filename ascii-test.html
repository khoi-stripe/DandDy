<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DALL-E → ASCII Test Lab</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #00ff00;
      padding: 20px;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 24px;
      color: #00ff00;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }
    
    .controls {
      background: #1a1a1a;
      border: 1px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      color: #00ff00;
    }
    
    input[type="text"],
    input[type="password"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 8px;
      background: #0a0a0a;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border-radius: 4px;
    }
    
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    .button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px 20px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .button:hover {
      background: rgba(0, 255, 0, 0.1);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }
    
    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .button-primary {
      background: rgba(0, 255, 0, 0.2);
    }
    
    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .results {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .result-panel {
      background: #1a1a1a;
      border: 1px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
    }
    
    .result-panel h2 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #00ff00;
    }
    
    .image-container {
      text-align: center;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .image-container img {
      max-width: 100%;
      border: 1px solid #00ff00;
      border-radius: 4px;
    }
    
    .ascii-output {
      font-family: monospace;
      white-space: pre;
      overflow: auto;
      background: #0a0a0a;
      padding: 10px;
      border: 1px solid #00ff00;
      border-radius: 4px;
      max-height: 600px;
      line-height: 1;
      text-align: center;
    }
    
    .status {
      background: #1a1a1a;
      border: 1px solid #00ff00;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 14px;
    }
    
    .status.loading {
      border-color: #ffff00;
      color: #ffff00;
      animation: pulse 1.5s infinite;
    }
    
    .status.success {
      border-color: #00ff00;
      color: #00ff00;
    }
    
    .status.error {
      border-color: #ff0000;
      color: #ff0000;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .hidden {
      display: none;
    }
    
    .stats {
      margin-top: 10px;
      font-size: 12px;
      color: #888;
    }
    
    .presets {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    
    .preset-button {
      padding: 5px 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>[ DALL-E → ASCII TEST LAB ]</h1>
    
    <div class="controls">
      <div class="control-group">
        <label>OpenAI API Key:</label>
        <input type="password" id="api-key" placeholder="sk-...">
        <div style="font-size: 12px; color: #888; margin-top: 5px;">Your key is stored locally in your browser</div>
      </div>
      
      <div class="control-group">
        <label>Character Prompt:</label>
        <textarea id="prompt" placeholder="Enter DALL-E prompt or use presets below..."></textarea>
        <div class="presets">
          <button class="button preset-button" onclick="usePreset('elf-wizard')">Elf Wizard</button>
          <button class="button preset-button" onclick="usePreset('dwarf-fighter')">Dwarf Fighter</button>
          <button class="button preset-button" onclick="usePreset('tiefling-warlock')">Tiefling Warlock</button>
          <button class="button preset-button" onclick="usePreset('human-paladin')">Human Paladin</button>
          <button class="button preset-button" onclick="usePreset('halfling-rogue')">Halfling Rogue</button>
        </div>
      </div>
      
      <div class="two-col">
        <div class="control-group">
          <label>ASCII Width (characters):</label>
          <input type="number" id="ascii-width" value="120" min="20" max="200">
        </div>
        <div class="control-group">
          <label>ASCII Height (characters):</label>
          <input type="number" id="ascii-height" value="60" min="10" max="100">
        </div>
      </div>
      
      <div class="control-group">
        <label>ASCII Font Size (px):</label>
        <input type="number" id="font-size" value="6" min="3" max="20">
      </div>
      
      <div class="control-group">
        <label>Character Set:</label>
        <select id="charset">
          <option value="extended">Extended (70 chars) - Best quality</option>
          <option value="standard">Standard (10 chars) - Simple</option>
          <option value="blocks">Blocks (4 chars) - Bold</option>
        </select>
      </div>
      
      <button class="button button-primary" id="generate-btn" onclick="generate()">GENERATE</button>
    </div>
    
    <div id="status" class="status hidden"></div>
    
    <div id="results" class="results hidden">
      <div class="result-panel">
        <h2>[ DALL-E IMAGE ]</h2>
        <div class="image-container" id="image-container">
          <span style="color: #888;">No image generated yet</span>
        </div>
        <div class="stats" id="image-stats"></div>
      </div>
      
      <div class="result-panel">
        <h2>[ ASCII CONVERSION ]</h2>
        <div class="ascii-output" id="ascii-output">
          <span style="color: #888;">No ASCII art generated yet</span>
        </div>
        <div class="stats" id="ascii-stats"></div>
      </div>
    </div>
  </div>

  <script>
    // ===== CONFIG =====
    const API_KEY_STORAGE = 'dnd_openai_key';
    
    // Character set options
    const CHARSETS = {
      extended: '$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,"^`\'.  ',
      standard: '@%#*+=-:. ',
      blocks: '█▓▒░ '
    };
    
    // Character presets
    const PRESETS = {
      'elf-wizard': {
        race: 'elf',
        class: 'wizard',
        alignment: 'neutral-good'
      },
      'dwarf-fighter': {
        race: 'dwarf',
        class: 'fighter',
        alignment: 'lawful-good'
      },
      'tiefling-warlock': {
        race: 'tiefling',
        class: 'warlock',
        alignment: 'chaotic-neutral'
      },
      'human-paladin': {
        race: 'human',
        class: 'paladin',
        alignment: 'lawful-good'
      },
      'halfling-rogue': {
        race: 'halfling',
        class: 'rogue',
        alignment: 'chaotic-good'
      }
    };
    
    // ===== INIT =====
    document.addEventListener('DOMContentLoaded', () => {
      // Load saved API key
      const savedKey = localStorage.getItem(API_KEY_STORAGE);
      if (savedKey) {
        document.getElementById('api-key').value = savedKey;
      }
      
      // Auto-save API key on change
      document.getElementById('api-key').addEventListener('change', (e) => {
        localStorage.setItem(API_KEY_STORAGE, e.target.value.trim());
      });
      
      // Update ASCII font size in real-time
      document.getElementById('font-size').addEventListener('input', (e) => {
        document.getElementById('ascii-output').style.fontSize = e.target.value + 'px';
      });
    });
    
    // ===== PRESET LOADER =====
    function usePreset(presetId) {
      const preset = PRESETS[presetId];
      const prompt = buildPrompt(preset);
      document.getElementById('prompt').value = prompt;
    }
    
    function buildPrompt(character) {
      const parts = [];
      
      // ASCII-optimized style directives
      parts.push('High contrast black and white fantasy character portrait');
      parts.push('bold dark outlines, dramatic chiaroscuro lighting');
      parts.push('simple clear shapes, strong silhouette');
      parts.push('ink drawing style with clear shadows and highlights');
      
      // Race
      const raceDescriptions = {
        human: 'human with defined facial features',
        elf: 'elf with prominent pointed ears and angular face',
        dwarf: 'dwarf with bold thick beard and strong features',
        halfling: 'halfling with round cheerful face',
        tiefling: 'tiefling with curved horns and sharp features',
      };
      if (character.race) {
        parts.push(raceDescriptions[character.race] || character.race);
      }
      
      // Class
      const classDescriptions = {
        fighter: 'in bold plate armor with clear geometric shapes, holding sword with strong outline',
        wizard: 'in flowing robes with distinct pointed hat, staff with clear silhouette',
        rogue: 'in dark fitted leather with hood, dual daggers with sharp edges',
        paladin: 'in shining armor with bold shield design, heroic stance',
        warlock: 'with dark robes and clear occult symbols, mysterious stance',
      };
      if (character.class) {
        parts.push(classDescriptions[character.class] || character.class);
      }
      
      // Alignment lighting
      if (character.alignment) {
        if (character.alignment.includes('good')) {
          parts.push('lit from above with heroic lighting');
        } else if (character.alignment.includes('evil')) {
          parts.push('lit from below with ominous shadows');
        } else {
          parts.push('side lighting with balanced light and shadow');
        }
      }
      
      // Final directives
      parts.push('full body centered portrait, plain background');
      parts.push('extremely high contrast, no gradual gradients');
      parts.push('bold clean edges suitable for line art conversion');
      
      return parts.join(', ');
    }
    
    // ===== MAIN GENERATION =====
    async function generate() {
      const apiKey = document.getElementById('api-key').value.trim();
      const prompt = document.getElementById('prompt').value.trim();
      const width = parseInt(document.getElementById('ascii-width').value);
      const height = parseInt(document.getElementById('ascii-height').value);
      const fontSize = parseInt(document.getElementById('font-size').value);
      const charsetType = document.getElementById('charset').value;
      
      // Validation
      if (!apiKey) {
        showStatus('Please enter your OpenAI API key', 'error');
        return;
      }
      
      if (!prompt) {
        showStatus('Please enter a prompt or select a preset', 'error');
        return;
      }
      
      // Disable button
      const btn = document.getElementById('generate-btn');
      btn.disabled = true;
      btn.textContent = 'GENERATING...';
      
      try {
        // Step 1: Generate DALL-E image
        showStatus('Step 1/2: Generating DALL-E image... (~10-15 seconds)', 'loading');
        const imageUrl = await generateDallEImage(apiKey, prompt);
        
        if (!imageUrl) {
          throw new Error('Failed to generate DALL-E image');
        }
        
        // Show image
        document.getElementById('results').classList.remove('hidden');
        document.getElementById('image-container').innerHTML = `<img src="${imageUrl}" alt="Generated image">`;
        document.getElementById('image-stats').textContent = `Image URL: ${imageUrl.substring(0, 50)}...`;
        
        // Step 2: Convert to ASCII
        showStatus('Step 2/2: Converting to ASCII with Floyd-Steinberg dithering...', 'loading');
        const startTime = Date.now();
        const asciiArt = await convertToAscii(imageUrl, width, height, charsetType);
        const duration = ((Date.now() - startTime) / 1000).toFixed(2);
        
        if (!asciiArt) {
          throw new Error('Failed to convert to ASCII');
        }
        
        // Show ASCII
        const outputEl = document.getElementById('ascii-output');
        outputEl.style.fontSize = fontSize + 'px';
        outputEl.textContent = asciiArt;
        document.getElementById('ascii-stats').textContent = 
          `Size: ${width}×${height} characters (${(width * height).toLocaleString()} total) | ` +
          `Font: ${fontSize}px | Conversion time: ${duration}s`;
        
        showStatus('✓ Generation complete!', 'success');
        
      } catch (error) {
        console.error('Generation error:', error);
        console.error('Error stack:', error.stack);
        showStatus(`Error: ${error.message || 'Unknown error'}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'GENERATE';
      }
    }
    
    // ===== DALL-E API =====
    async function generateDallEImage(apiKey, prompt) {
      const response = await fetch('https://api.openai.com/v1/images/generations', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: 'dall-e-3',
          prompt: prompt,
          n: 1,
          size: '1024x1024',
          quality: 'standard',
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`DALL-E API error: ${error.error?.message || response.status}`);
      }
      
      const data = await response.json();
      return data.data[0].url;
    }
    
    // ===== ASCII CONVERTER =====
    async function convertToAscii(imageUrl, width, height, charsetType) {
      try {
        console.log('Starting ASCII conversion...', { imageUrl, width, height, charsetType });
        
        const charset = CHARSETS[charsetType];
        console.log('Charset loaded:', charset ? `${charset.length} characters` : 'MISSING');
        
        if (!charset) {
          throw new Error(`Invalid charset type: ${charsetType}`);
        }
        
        // Load image
        console.log('Loading image...');
        const img = await loadImage(imageUrl);
        console.log('Image loaded:', img.width, 'x', img.height);
        
        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // Draw image
        ctx.drawImage(img, 0, 0, width, height);
        console.log('Image drawn to canvas');
        
        // Get pixel data
        const imageData = ctx.getImageData(0, 0, width, height);
        const pixels = imageData.data;
        console.log('Pixel data extracted:', pixels.length, 'values');
        
        // Convert to grayscale
        const grayscale = new Float32Array(width * height);
        for (let i = 0; i < width * height; i++) {
          const idx = i * 4;
          grayscale[i] = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
        }
        console.log('Converted to grayscale');
        
        // Apply Floyd-Steinberg dithering
        console.log('Applying Floyd-Steinberg dithering...');
        const dithered = floydSteinbergDither(grayscale, width, height, charset.length);
        console.log('Dithering complete');
        
        // Convert to ASCII
        console.log('Converting to ASCII characters...');
        let ascii = '';
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const brightness = dithered[y * width + x];
            const charIndex = Math.floor((brightness / 255) * (charset.length - 1));
            const clampedIndex = Math.max(0, Math.min(charset.length - 1, charIndex));
            ascii += charset[charset.length - 1 - clampedIndex];
          }
          ascii += '\n';
        }
        console.log('ASCII conversion complete:', ascii.length, 'characters');
        
        return ascii;
      } catch (error) {
        console.error('Error in convertToAscii:', error);
        throw new Error(`ASCII conversion failed: ${error.message}`);
      }
    }
    
    function floydSteinbergDither(grayscale, width, height, levels) {
      const output = new Float32Array(grayscale);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          const oldPixel = output[idx];
          
          // Quantize
          const newPixel = Math.round((oldPixel / 255) * (levels - 1)) * (255 / (levels - 1));
          output[idx] = newPixel;
          
          // Calculate error
          const error = oldPixel - newPixel;
          
          // Distribute error
          if (x + 1 < width) {
            output[idx + 1] += error * 7 / 16;
          }
          if (y + 1 < height) {
            if (x > 0) {
              output[idx + width - 1] += error * 3 / 16;
            }
            output[idx + width] += error * 5 / 16;
            if (x + 1 < width) {
              output[idx + width + 1] += error * 1 / 16;
            }
          }
        }
      }
      
      return output;
    }
    
    async function loadImage(url) {
      try {
        console.log('Fetching image as blob to bypass CORS...');
        // Fetch the image as a blob to bypass CORS restrictions
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch image: ${response.status}`);
        }
        
        const blob = await response.blob();
        console.log('Blob loaded:', blob.size, 'bytes');
        
        // Create object URL from blob
        const objectUrl = URL.createObjectURL(blob);
        console.log('Object URL created:', objectUrl.substring(0, 50) + '...');
        
        // Load image from object URL
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            console.log('Image loaded successfully:', img.width, 'x', img.height);
            // Clean up object URL
            URL.revokeObjectURL(objectUrl);
            resolve(img);
          };
          img.onerror = (error) => {
            console.error('Image load error:', error);
            URL.revokeObjectURL(objectUrl);
            reject(new Error('Failed to load image from blob'));
          };
          img.src = objectUrl;
        });
      } catch (error) {
        console.error('Error in loadImage:', error);
        throw new Error(`Image loading failed: ${error.message}`);
      }
    }
    
    // ===== UI HELPERS =====
    function showStatus(message, type) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
      statusEl.classList.remove('hidden');
    }
  </script>
</body>
</html>

